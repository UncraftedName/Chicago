#include "ch_dump_decl.h"

// TODO yeah i'll need to check for nulls at every possible failure, fun :)
static ch_err ch_dump_sav_text(ch_dump_text* dump, const ch_parsed_save_data* save_data)
{
    CH_RET_IF_ERR(CH_DUMP_TEXT_CALL(g_dump_tag_fns, dump, &save_data->tag));
    CH_RET_IF_ERR(
        CH_DUMP_TEXT_CALL(g_dump_restored_class_fns, dump, save_data->game_header.dm, save_data->game_header.data));
    CH_RET_IF_ERR(
        CH_DUMP_TEXT_CALL(g_dump_restored_class_fns, dump, save_data->global_state.dm, save_data->global_state.data));
    for (size_t i = 0; i < save_data->n_state_files; i++) {
        ch_state_file* sf = &save_data->state_files[i];
        CH_RET_IF_ERR(ch_dump_text_printf(dump,
                                          "\nstate file \"%.*s\" (%s):\n",
                                          sizeof sf->name,
                                          sf->name,
                                          ch_sf_type_strs[sf->type]));
        dump->indent_lvl++;
        switch (sf->type) {
            case CH_SF_SAVE_DATA:
                CH_RET_IF_ERR(CH_DUMP_TEXT_CALL(g_dump_hl1_fns, dump, sf->data));
                break;
            case CH_SF_ADJACENT_CLIENT_STATE:
                CH_RET_IF_ERR(CH_DUMP_TEXT_CALL(g_dump_hl2_fns, dump, sf->data));
                break;
            case CH_SF_ENTITY_PATCH:
                CH_RET_IF_ERR(CH_DUMP_TEXT_CALL(g_dump_hl3_fns, dump, sf->data));
                break;
            case CH_SF_INVALID:
            default:
                CH_RET_IF_ERR(ch_dump_text_printf(dump, "INVALID"));
                break;
        }
        dump->indent_lvl--;
    }

    if (save_data->errors_ll) {
        CH_RET_IF_ERR(ch_dump_text_printf(dump, "\n\nErrors during parsing:\n"));
        dump->indent_lvl++;
        CH_DUMP_TEXT_CALL(g_dump_str_ll_fns, dump, save_data->errors_ll, CH_DUMP_TEXT_STR_LL_NL_SEP);
        CH_RET_IF_ERR(ch_dump_text_printf(dump, "\n"));
        dump->indent_lvl--;
    }
    return CH_ERR_NONE;
}

const ch_dump_sav_fns g_dump_sav_fns = {
    .text = ch_dump_sav_text,
};

ch_err ch_dump_sav_to_text(FILE* f, const ch_parsed_save_data* save_data, const char* indent_str, ch_dump_flags flags)
{
    size_t ind_len = strlen(indent_str);
    assert(ind_len < 16); // what even is this indent string my dude
    ind_len = min(ind_len, 16);

    ch_dump_text rdump = {
        .f = f,
        .indent_str_len = (uint8_t)ind_len,
        .flags = flags,
        .pending_nl = false,
        .indent_lvl = 0,
    };
    rdump.arena = ch_arena_new(0);
    if (!rdump.arena)
        return CH_ERR_OUT_OF_MEMORY;

    ch_err err = CH_ERR_NONE;

    // init indent string buf
    rdump.indent_str_buf = ch_arena_alloc(rdump.arena, CH_DUMP_TEXT_MAX_INDENT * ind_len + 1);
    if (!rdump.indent_str_buf) {
        err = CH_ERR_OUT_OF_MEMORY;
    } else {
        for (size_t i = 0; i < CH_DUMP_TEXT_MAX_INDENT; i++)
            sprintf(rdump.indent_str_buf + i * ind_len, "%.*s", (int)ind_len, indent_str);
    }

    ch_dump_text* dump = &rdump;

    // error checking hell to make sure we free the arena
    if (!err)
        err = ch_dump_text_printf(dump, "Save dump generated by Chicago save parser.\n\n");
    if (!err)
        err = CH_DUMP_TEXT_CALL(g_dump_sav_fns, dump, (void*)save_data);

    if (dump->first_error) {
        if (!err)
            err = ch_dump_text_printf(dump, "\n\nErrors during dumping:\n");
        dump->indent_lvl++;
        if (!err)
            err = CH_DUMP_TEXT_CALL(g_dump_str_ll_fns, dump, dump->first_error, CH_DUMP_TEXT_STR_LL_NL_SEP);
        if (!err)
            err = ch_dump_text_printf(dump, "\n");
        dump->indent_lvl--;
    }
    if (!err)
        err = ch_dump_text_flush_nl(dump);
    ch_arena_free(dump->arena);
    return err;
}
